# 協議設計最核心解決的問題

1. 序列化/反序列化
2. 判斷包的完整性

# 序列化/反序列化

1. TLV 編碼 以及其變體 （TLV是tag，length和value的縮寫）： Protobuf
2. 文本流編碼 ： xml/json
3. 固定結構編碼： 基本原理是，協議約定了傳輸字段類型和字段含義，和TLV的方式類似，但是沒有了tag和len，只有value，比如 TCP/IP
4. 內存dump：基本原理是，把內存中的數據直接輸出，不做任何序列化操作。反序列化的時候直接還原內存

# 判斷包的完整性

1. 以固定大小字節數進行分界，如每個包100字節，對端收齊100字節，當成一個包解析。 現在沒有任何人這樣做
2. 以特定符號來分界，比如 \r \n, 當字節流讀到就知道上一個包到此為止。很少單獨這樣用了
3. 固定包頭 + 包體結構，這種結構中一般包頭部分是一個固定字節長度的結構，並且包頭中會有一個特定的字段指定包體的大小。先接收固定長度的頭，再按頭所給的包體大小進行收包解析。
4. 在序列化後的buffer前面增加一個字符流的頭部，其中有個字段存儲包總長度，根據特殊字符判斷頭部的完整性。這樣通常比3麻煩，HTTP和REDIS均採用這種方法。收包的時候，先判斷已收到的數據中是否包含結束符，收到結束符後解析包頭，解出包完整長度，按此長度接收包體。

# 協議涉及範例參考1

|   字段  | 類型 | 長度（字節）| 說明|  
| ------------- | ------------- | ------------- | ------------- |
| STAG  | unsigned short|2|通信協議數據包的開始標誌 0xff 0xfe |
| *version  | unsigned short  | 2 | 通信協議的版本號，目前為0x01|
| checksum  | unsigned char  | 1 | 計算協議數據校驗和，如果為加密數據，則計算秘文校驗和|
| *type  | unsigned char  | 1 |0表示協議體是json格式，其他值未定義。設備心跳信息類 0xA0|
| *seqno  | unsigned int | 4 |通信報文的序列號，跟tcp的一樣，讓ACK 返回的時候用來確認對方真的收到信息|
| *Length | unsigned short  | 2 |報文內容長度，既從該字段後的報文內容長度|
| *reverse  | unsigned short| 2 |預留字節|
| *body  | unsigned char [] | n |數據|

# 即時通訊協議設計範例

|   字段  | 類型 | 長度（字節）| 說明|  
| ------------- | ------------- | ------------- | ------------- |
| *Length | unsigned short  | 2 |整個包的長度，包括協議頭+body|
| *version  | unsigned short  | 2 | 通信協議的版本號，目前為0x01|
| appid  | unsigned short  | 2 | 對外SDK提供服務時，用來識別不同的客戶|
| *service_id  | unsigned short  | 2 |對應命令的分組類比，比如login和msg是不同組|
| *command_id | unsigned short  | 2 |分組裡的子命令|
| *seqno  | unsigned int | 4 |通信報文的序列號，跟tcp的一樣，讓ACK 返回的時候用來確認對方真的收到信息|
| *reverse  | unsigned short| 2 |預留字節|
| *body  | unsigned char [] | n |數據|

# 分包 粘包 概念

一幁就是一個包

就像即時通訊協議設計範例一樣，每個包頭帶有整個包的長度，包被分開之後發送到peer，peer存在一個環形的buffer，如果他發現包頭長度寫著100字節，可是當前包大小只有50，他不會解析這個包而是等待另外50個字節到來，一併拆包。

分包能夠加大網絡通訊的吞吐量。

# 常用的協議設計

1. HTTP協議
2. Redis協議

問題：假如一個數據包超過了內核緩衝區大小怎麼辦？ 不會有這種問題，tcp傳輸層在建立連接後已經確保不會有這個問題了。

